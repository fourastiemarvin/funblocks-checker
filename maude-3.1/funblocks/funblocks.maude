fmod FUNBLOCKS is
  protecting META-LEVEL .
  --- including VENDING-MACHINE-SIGNATURE .
  --- including FUNBLOCKS-SYNTAX .
  inc LEXICAL .

  vars T T1 T2 T3 : Term . --- terms for declaration (module, eq,...)
  vars TL TL' : TermList . --- to get the list of tokens
  var  QI : Qid .        ---Qid used in solveBubbles to interprete parsed input
  var  QIL : QidList .
  var  F : Qid .        --- used in conditions of which parsed input we compute
  var  M : Module .  --- Module we currently building
  var R : Rule .
  --- var D : Decl .

  op getCase : ResultPair ~> QidList .
  eq getCase({'case_=>_[T1, T2], 'Decl})
   = solveBubble(T1, T2) .

  op solveBubble : Term Term ~> QidList .
  op solveBubbleAux : Term ~> QidList .

 --- redirect to getVar(), getConst() or getFunc()
  eq solveBubble(T1, T2)
   = solveBubbleAux(T1) solveBubbleAux(T2) . --- getRule(T1, T2) .

  eq solveBubbleAux('bubble['__[''$.Qid, QI]])
   = getVar(QI) .

  --- eq solveBubbleAux('bubble['_[QI]])
  ---  = getConst(QI) .

  --- eq solveBubbleAux('bubble['_(_)[QI1, QI2]])
  ---  = getFunc(QI1, solveBubbleAux(QI2)) .

  op getVar : Qid ~> QidList .
  eq getVar(QI)
   = 'var tokenize("$" + string(getName(QI))) ': 'Untyped '. '\n .

  op getConst : Qid ~> QidList .

  op getFunc : Qid QidList ~> QidList .

--- TODO
  op getRule : Term Term ~> QidList .
  eq getRule(T1, T2)
   = 'rl T1 '=> T2 '. .


endfm

--- TESTS

load funblocks-syntax.maude

reduce in FUNBLOCKS :
  --- solveBubble(tokenize("$ f")) .
  getCase(metaParse(upModule('FUNBLOCKS-SYNTAX, false), tokenize("case $ f => $ g"), anyType)) .
  --- getCase(metaParse(upModule('FUNBLOCKS-SYNTAX, false), tokenize("$ f"), anyType)) .



   --- tokenize("case $f => $g")
   --- solveBubbles(
   ---   getTerm(metaParse(upModule('FUNBLOCKS-SYNTAX, false),
   ---    tokenize("case $ f => $ g") , anyType)
   ---        )) .
--- reduce in FUNBLOCKS :
---    getName(processTerm(solveBubblesAux('bubble[''f.Qid]))) .
