fmod FUNBLOCKS is
  protecting META-LEVEL .
  --- including VENDING-MACHINE-SIGNATURE .

  vars T T1 T2 T3 : Term . --- terms for declaration (module, eq,...)
  vars TL TL' : TermList . --- to get the list of tokens
  var  QI : Qid .        ---Qid used in solveBubbles to interprete parsed input
  var  QIL : QidList .
  var  F : Qid .        --- used in conditions of which parsed input we compute
  var  M : Module .  --- Module we currently building
  var R : Rule .

  --- the following ones are used to build the module containing imports,
  --- sorts, op, axioms and equation
  var  I : Import .
  vars IL : ImportList .
  var  S : Sort .
  vars SS : SortSet .
  var  SsS : SubsortDeclSet .
  var  OD : OpDecl .
  var  ODS : OpDeclSet .
  var  MbS : MembAxSet .
  vars EqS EqS' : EquationSet .
  var RlS : RuleSet .

  --- "root" function who parse the entire input T
  op processModule : Term ~> SModule .
  eq processModule(T)
   = solveBubbles(T,
        mod 'FUNRULES is nil sorts none . none none none none none endm ) .

  op solveBubbles : Term SModule ~> SModule .
  eq solveBubbles('case_=>_[T1, T2], M)
  --- eq solveBubbles(T)
   --- = getTerm(processTerm(T1, M)) .
   = addRule(rl getTerm(processTerm(T1, M)) => getTerm(processTerm(T2, M)) [none] .) .

 op processTerm : Term SModule ~> ResultPair .
 eq processTerm('bubble[T], M)
   = metaParse(M, downTerm(T, nil), anyType) .

  op addRule : Rule ~> SModule .
  eq addRule(R)
   = mod 'FUNRULES is nil sorts none . none none none none R endm .
  --- op showRules : Qid -> SModule .
  --- eq showRules('TEST)
  ---  = mod Qid is nil sorts none . none none none none rl 'T1 => 'T2 . endm .

endfm

--- TESTS

load funblocks-syntax.maude
--- load vending-machine.maude

reduce in FUNBLOCKS :
    --- processModule(rl 'M:haah => 'M:Marking [none] .) .
    --- addRule(rl 'M:type => 'M:type [none] .) .
    --- upModule('FUNRULES, false) .
    --- solveBubbles('case 'f '=> 'g,
    ---   mod 'FUNRULES is nil sorts none . none none none none none endm ) .
    metaParse(upModule('FUNBLOCKS-SYNTAX, false),
          downTerm('case 'f '=> 'g, nil), anyType) .

--- reduce in FUNBLOCKS :
---    processModule(
---      getTerm(metaParse(upModule('FUNBLOCKS-SYNTAX, false),
---       'case 'f '=> 'g, anyType)
---           --- ) .
---       )) .

--- reduce in FUNBLOCKS :
---   addRules(mod 'FUNRULES is nil sorts none . none none none none none endm, (rl 'f '=> 'g [none]) ) .
