load maybe.maude
load funblocks.maude
load funblocks-syntax.maude
load file.maude
load metaInterpreter.maude

view Oid from TRIV to CONFIGURATION is
  sort Elt to Oid .
endv

view Module from TRIV to META-MODULE is
  sort Elt to Module .
endv

mod FUNBLOCKS-META-INTERPRETER is
  pr FUNBLOCKS .
  inc STD-STREAM .
  inc LEXICAL .
  inc MAYBE{Oid} * (op maybe to null) .
  inc MAYBE{Qid} * (op maybe to null) .
  inc MAYBE{Module} * (op maybe to null) .
  inc META-INTERPRETER .

  vars O O' MI Y : Oid .
  var  Atts : AttributeSet .
  var  QIL : QidList .
  var  Str : String .
  vars T T' : Term .
  vars Ty Ty' : Type .
  var  N : Nat .
  var  RP? : [ResultPair] .
  var  M : Module .
  var  M? : Maybe{Module} .
  vars QI? : Maybe{Qid} .
  vars QI MN : Qid .
  var  EqS : EquationSet .

  sort FunBlocks .
  subsort FunBlocks < Cid .
  op FunBlocks : -> FunBlocks .
  op mi:_ : Maybe{Oid} -> Attribute [prec 20 gather (&)] .    ---- meta-interpreter
  op mn:_ : Maybe{Qid} -> Attribute [prec 20 gather (&)] .    ---- default module name
  op in:_ : QidList -> Attribute [prec 20 gather (&)] .       ---- accumulated input
  op st:_ : Nat -> Attribute [prec 20 gather (&)] .           ---- state

  op processInput : Oid Term -> Msg .
  op pendingBubbles : Oid Term -> Msg .
  op parsedEquations : Oid EquationSet -> Msg .
  op processReduce : Oid [ResultPair] -> Msg .

  op o : -> Oid .
  op funblocks : -> Configuration .

  --- init
  eq funblocks
   = <>
     < o : FunBlocks | mi: null, mn: null, in: nil, st: 0 >
     write(stdout, o, "'\n\t FunBlocks Execution Environment\n")
     createInterpreter(interpreterManager, o, none) .

  --- create interpreter with syntax module included
  rl < O : FunBlocks | mi: null, st: 0, Atts >
     wrote(O, O')
     createdInterpreter(O, Y, MI)
  => < O : FunBlocks | mi: MI, st: 1, Atts >
     insertModule(MI, O, upModule('FUNBLOCKS-SYNTAX, true)) .

  --- waiting for an input while module inserted
  rl < O : FunBlocks | mi: MI, st: 1, Atts >
     insertedModule(O, O')
  => < O : FunBlocks | mi: MI, st: 2, Atts >
     getLine(stdin, O, "funblocks> ") .

  --- exit if "q" or "quit" typed, else parse input
  rl < O : FunBlocks | mi: MI, in: QIL, st: 2, Atts >
     gotLine(O, O', Str)
  => if tokenize(Str) == 'quit or tokenize(Str) == 'q
     then < O : FunBlocks | mi: MI, in: nil, st: 3, Atts >
          write(stdout, o, "goodbye\n")
          quit(MI, O)
     --- else < O : FunBlocks | mi: MI, in: QIL, st: 2, Atts >
     ---      getLine(stdin, O, "funblocks> ")
     --- fi .
     else < O : FunBlocks | mi: MI, in: QIL tokenize(Str), st: 4, Atts >
          parseTerm(MI, O, 'FUNBLOCKS-SYNTAX, none, QIL tokenize(Str), 'Input)
     fi .

  --- exit interpreter
  rl < O : FunBlocks | mi: MI, st: 3, Atts >
     wrote(O, O')
     bye(O, MI)
  => none .

  --- if term is parsed with success, process the input
  rl < O : FunBlocks | mi: MI, in: QIL, st: 4, Atts >
     parsedTerm(O, MI, {T, Ty})
  => < O : FunBlocks | mi: MI, in: nil, st: 6, Atts >
     processInput(O, T) .

--- endpoint after line written
 rl < O : FunBlocks | mi: MI, st: 5, Atts >
    wrote(O, O')
 => < O : FunBlocks | mi: MI, st: 2, Atts >
    getLine(stdin, O, "funblocks> ") .

  --- if no parse, come back to state 2 (wait input)
  --- rl < O : FunBlocks | mi: MI, in: QIL, st: 4, Atts >
  ---    parsedTerm(O, MI, noParse(N))
  --- => if N == size(QIL)
  ---    then < O : FunBlocks | mi: MI, in: QIL, st: 2, Atts >
  ---         getLine(stdin, O, "> ")
  ---    else < O : FunBlocks | mi: MI, in: nil, st: 5, Atts >
  ---         write(stdout, o, "Parse error\n")
  ---    fi .

 --- no parse for input
 rl < O : FunBlocks | mi: MI, in: QIL, st: 4, Atts >
    parsedTerm(O, MI, noParse(N))
 => < O : FunBlocks | mi: MI, in: nil, st: 5, Atts >
    write(stdout, o, "Parse error\n") .

  --- Detect ambiguity
  rl < O : FunBlocks | mi: MI, in: QIL, st: 4, Atts >
     parsedTerm(O, MI, ambiguity({T, Ty}, {T', Ty'}))
  => < O : FunBlocks | mi: MI, in: nil, st: 5, Atts >
     write(stdout, o, "Ambiguous input\n") .

  rl < O : FunBlocks | mi: MI, mn: QI?, st: 6, Atts >
     processInput(O, 'case_=>_[T, T'])
  => if extractSignature('case_=>_[T, T']) :: Module
     then < O : FunBlocks | mi: MI, mn: 'FUNRULES, st: 7, Atts >
          insertModule(MI, O, extractSignature('case_=>_[T, T']))
     else < O : FunBlocks | mi: MI, mn: QI?, st: 5, Atts >
          write(stdout, o, "Parse error\n")
     fi .

  rl < O : FunBlocks | mi: MI, mn: QI, st: 7, Atts >
     insertedModule(O, MI)
  => < O : FunBlocks | mi: MI, st: 5, Atts >
     write(stdout, O, "Module loaded successfully\n") .

  endm

erew funblocks .
