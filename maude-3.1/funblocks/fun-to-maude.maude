load file.maude
load maybe.maude
load funblocks.maude
load funblocks-syntax.maude
load metaInterpreter.maude

fmod MAYBE{X :: TRIV} is
  sort Maybe{X} .
  subsort X$Elt < Maybe{X} .
  op null : -> Maybe{X} .
endfm

view Oid from TRIV to CONFIGURATION is
  sort Elt to Oid .
endv

mod FUN-TO-MAUDE is
  inc FILE .
  pr MAYBE{Oid} .
  inc FUNBLOCKS .
  inc LEXICAL .
  inc STD-STREAM .

  op myClass : -> Cid .
  op myObj : -> Oid .
  ops in:_ out:_ : Maybe{Oid} -> Attribute .
  ops inFile:_ outFile:_ : String -> Attribute .
  op isEnd:_ : Bool -> Attribute .

  op run : String String -> Configuration .
  vars Text Fun Maude : String .
  vars FHIn FHOut AnyOutput : Oid .
  var  Attrs : AttributeSet .

  var R : QidList .
  var N : Nat .

  op parsedRule : Oid QidList -> Msg .

  --- start: open input file on read mode
  eq run(Fun, Maude)
   = <>
     < myObj : myClass | in: null, inFile: Fun, out: null, outFile: Maude >
     openFile(fileManager, myObj, Fun, "r") .

  --- when input file opened, open output file on write mode
  rl < myObj : myClass | in: null, outFile: Maude, Attrs >
     openedFile(myObj, fileManager, FHIn)
  => < myObj : myClass | in: FHIn, Attrs >
     openFile(fileManager, myObj, Maude, "w") .

  --- when output file opened, write the module decl in output file
  rl < myObj : myClass | in: FHIn, out: null, Attrs >
     openedFile(myObj, fileManager, FHOut)
  => < myObj : myClass | in: FHIn, out: FHOut, Attrs >
     write(FHOut, myObj,
        "mod FUN-RULES is \n") .

  --- when module decl wrote, get line of input file
  rl < myObj : myClass | in: FHIn, out: FHOut, Attrs >
     wrote(myObj, FHOut)
  => < myObj : myClass | in: FHIn, out: FHOut, Attrs >
     getLine(FHIn, myObj) .

  rl < myObj : myClass | in: FHIn, out: FHOut, Attrs >
     gotLine(myObj, FHIn, Text)
  => if Text == ""
     then < myObj : myClass | in: FHIn, out: FHOut, isEnd: true, Attrs >
          write(FHOut, myObj, "endm \n")
     else < myObj : myClass | in: FHIn, out: FHOut, Attrs >
          parsedRule(myObj,getCase(
            metaParse(upModule('FUNBLOCKS-SYNTAX, false), tokenize(Text) , anyType)))
     fi .

  rl < myObj : myClass | in: FHIn, out: FHOut, Attrs >
    parsedRule(myObj, getCase(noParse(N)))
  => < myObj : myClass | in: FHIn, out: FHOut, Attrs >
    write(stdout, myObj, "syntax error \n") .

  rl < myObj : myClass | in: FHIn, out: FHOut, Attrs >
    parsedRule(myObj, R)
  => < myObj : myClass | in: FHIn, out: FHOut, Attrs >
    write(FHOut, myObj, printTokens(R '\n)) .

  rl < myObj : myClass | in: FHIn, out: FHOut, Attrs >
     wrote(myObj, AnyOutput)
  => < myObj : myClass | in: FHIn, out: FHOut, Attrs >
     getLine(FHIn, myObj) .

  rl < myObj : myClass | in: FHIn, out: FHOut, isEnd: true, Attrs >
     wrote(myObj, FHOut)
  => < myObj : myClass | in: FHIn, out: FHOut, isEnd: true, Attrs >
     closeFile(FHIn, myObj)
     closeFile(FHOut, myObj) .

  rl < myObj : myClass | in: FHIn, out: FHOut, isEnd: true, Attrs >
     closedFile(myObj, FHIn)
     closedFile(myObj, FHOut)
  => none .
endm

erew run("test.txt", "funrules.maude") .
